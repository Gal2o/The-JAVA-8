# JVM 구조
  - ![image](https://user-images.githubusercontent.com/35948339/134531703-b070cd5a-6c6b-430a-b3f7-a63e8625252d.png)
  - ## 클래스 로더 시스템
    - ### .class 에서 바이트 코드를 읽고 메모리에 배치한다
    - ![image](https://user-images.githubusercontent.com/35948339/134541302-5e549989-7fd0-4d01-95fc-c7f2ca565ebc.png)
    - #### 로딩 : class 읽어오는 과정
    - #### 링크 : 레퍼런스를 연결하는 과정
    - #### 초기화 : static 값들을 초기화 및 변수에 할당
  -------
  - ## 메모리
    - #### `메소드 영역` : 클래스 수준의 정보 (클래스 이름, 부모 클래스 이름, 메소드, 변수) 저장 <br><br> ➡ ♻ 공유자원
    - #### ![image](https://user-images.githubusercontent.com/35948339/134541897-90fdfcca-d5ba-46ee-875f-f67e9dd3076d.png) <br><br> `힙 영역` : 객체 및 인스턴스를 저장, 공유한다 ➡ ♻ 공유자원
    - #### ⭕ 나머지 영역들은 쓰레드끼리 공유하는 영역
    - #### `스택 영역` : 쓰레드 마다 런타임 스택을 만들고, 그 안에 메소드 호출을 `스택 프레임`이라는 블럭으로 쌓는다.
    - #### `PC 레지스터` : 각각 쓰레드마다 쓰레드 내 현재 실행할 스택 프레임을 가리키는 포인터가 생성된다
    - #### `네이티브 메소드 스택` : native 키워드가 붙어있는 인터페이스를 담는 곳
  -------
  - ## 실행 엔진
    - #### 인터프리터 : 바이트 코드를 한 줄씩 실행
    - #### Just-in-time 컴파일러 : 인터프리터 효율을 높이기 위해, 인터프리터가 반복해서 사용하는 코드를 발견하면 <br><br> JIT 컴파일러로 반복되는 코드를 네이티브 코드로 저장해둔다 (캐싱) ➡ 실행시간을 절약할 수 있다.
    - #### GC(Garbage Collector) : 더 이상 참조되지 않는 객체를 모아서 정리한다
  ------
  - ## JNI (Java Native Interface)
    - #### JAVA 애플리케이션에서 C, C++, 어셈블리어로 작성된 함수를 사용할 수 있는 방법 제공 <br><br> ex. Thread.currentThread()
    - #### Native 키워드를 사용한 메소드 호출
  - ## 네이티브 메소드 라이브러리
    - #### C, C++
